"""
Track service for managing track data and database operations.
Handles CRUD operations for tracks in the database.
"""

import logging
from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import uuid4

from backend.database.connection import get_database
from backend.database.schema import get_tracks_table, track_to_dict, dict_to_track, get_database_stats
from backend.models.track import Track, TrackCreate, TrackResponse, DatabaseStats

logger = logging.getLogger(__name__)


class TrackService:
    """Service for managing track data."""
    
    def __init__(self, db):
        """Initialize track service with database connection."""
        self.db = db
    
    async def create_track(self, track_data: TrackCreate) -> Track:
        """Create a new track in the database."""
        try:
            # Generate unique track ID
            track_id = str(uuid4())
            
            # Create track object
            now = datetime.utcnow()
            track = Track(
                track_id=track_id,
                title=track_data.title,
                artist=track_data.artist,
                album=track_data.album,
                year=track_data.year,
                genre=track_data.genre,
                tags=track_data.tags,
                youtube_url=track_data.youtube_url,
                album_art_url=track_data.album_art_url,
                lyrics=track_data.lyrics,
                semantic_description=track_data.semantic_description,
                mood=track_data.mood,
                tempo=track_data.tempo,
                instruments=track_data.instruments,
                text_embedding=None,  # Will be generated by embedding service
                image_embedding=None,  # Will be generated by embedding service
                audio_embedding=None,  # Will be generated by embedding service
                semantic_embedding=None,  # Will be generated by embedding service
                lyrics_embedding=None,  # Will be generated by embedding service
                created_at=now,
                updated_at=now
            )
            
            # Convert to dictionary for database storage
            track_dict = track_to_dict(track)
            
            # Insert into database
            table = get_tracks_table(self.db)
            table.add([track_dict])
            
            logger.info(f"Created track: {track_id} - {track.title} by {track.artist}")
            return track
            
        except Exception as e:
            logger.error(f"Failed to create track: {str(e)}")
            raise
    
    async def get_track(self, track_id: str) -> Optional[Track]:
        """Get a track by ID."""
        try:
            table = get_tracks_table(self.db)
            
            # Search for track by ID
            result = table.search().where(f"track_id = '{track_id}'").to_df()
            
            if result.empty:
                return None
            
            # Convert first result to Track object
            track_data = result.iloc[0].to_dict()
            return dict_to_track(track_data)
            
        except Exception as e:
            logger.error(f"Failed to get track {track_id}: {str(e)}")
            raise
    
    async def list_tracks(self, skip: int = 0, limit: int = 50) -> List[Track]:
        """List tracks with pagination."""
        try:
            table = get_tracks_table(self.db)
            
            # Get all tracks and apply pagination
            df = table.to_pandas()
            
            if df.empty:
                return []
            
            # Sort by created_at descending
            df = df.sort_values('created_at', ascending=False)
            
            # Apply pagination
            start_idx = skip
            end_idx = skip + limit
            paginated_df = df.iloc[start_idx:end_idx]
            
            # Convert to Track objects
            tracks = []
            for _, row in paginated_df.iterrows():
                track_data = row.to_dict()
                track = dict_to_track(track_data)
                tracks.append(track)
            
            return tracks
            
        except Exception as e:
            logger.error(f"Failed to list tracks: {str(e)}")
            raise
    
    async def update_track(self, track_id: str, track_data: TrackCreate) -> Optional[Track]:
        """Update an existing track."""
        try:
            # Get existing track
            existing_track = await self.get_track(track_id)
            if not existing_track:
                return None
            
            # Update fields
            updated_track = Track(
                track_id=track_id,
                title=track_data.title,
                artist=track_data.artist,
                album=track_data.album,
                year=track_data.year,
                genre=track_data.genre,
                tags=track_data.tags,
                youtube_url=track_data.youtube_url,
                album_art_url=track_data.album_art_url,
                lyrics=track_data.lyrics,
                semantic_description=track_data.semantic_description,
                mood=track_data.mood,
                tempo=track_data.tempo,
                instruments=track_data.instruments,
                text_embedding=existing_track.text_embedding,  # Keep existing embeddings
                image_embedding=existing_track.image_embedding,
                audio_embedding=existing_track.audio_embedding,
                semantic_embedding=existing_track.semantic_embedding,
                lyrics_embedding=existing_track.lyrics_embedding,
                created_at=existing_track.created_at,
                updated_at=datetime.utcnow()
            )
            
            # Convert to dictionary
            track_dict = track_to_dict(updated_track)
            
            # Update in database
            table = get_tracks_table(self.db)
            table.update(where=f"track_id = '{track_id}'", values=track_dict)
            
            logger.info(f"Updated track: {track_id}")
            return updated_track
            
        except Exception as e:
            logger.error(f"Failed to update track {track_id}: {str(e)}")
            raise
    
    async def delete_track(self, track_id: str) -> bool:
        """Delete a track by ID."""
        try:
            table = get_tracks_table(self.db)
            
            # Check if track exists
            result = table.search().where(f"track_id = '{track_id}'").to_df()
            if result.empty:
                return False
            
            # Delete track
            table.delete(f"track_id = '{track_id}'")
            
            logger.info(f"Deleted track: {track_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to delete track {track_id}: {str(e)}")
            raise
    
    async def search_tracks_by_metadata(self, query: str, limit: int = 20) -> List[Track]:
        """Search tracks by metadata using text search."""
        try:
            table = get_tracks_table(self.db)
            
            # Simple text search across title, artist, genre, tags
            search_conditions = []
            query_lower = query.lower()
            
            search_conditions.append(f"LOWER(title) LIKE '%{query_lower}%'")
            search_conditions.append(f"LOWER(artist) LIKE '%{query_lower}%'")
            search_conditions.append(f"LOWER(genre) LIKE '%{query_lower}%'")
            search_conditions.append(f"LOWER(tags) LIKE '%{query_lower}%'")
            search_conditions.append(f"LOWER(lyrics) LIKE '%{query_lower}%'")
            
            where_clause = " OR ".join(search_conditions)
            
            # Search and limit results
            result = table.search().where(where_clause).limit(limit).to_df()
            
            # Convert to Track objects
            tracks = []
            for _, row in result.iterrows():
                track_data = row.to_dict()
                track = dict_to_track(track_data)
                tracks.append(track)
            
            return tracks
            
        except Exception as e:
            logger.error(f"Failed to search tracks by metadata: {str(e)}")
            raise
    
    async def get_tracks_by_filters(self, filters: Dict[str, Any], limit: int = 50) -> List[Track]:
        """Get tracks filtered by various criteria."""
        try:
            table = get_tracks_table(self.db)
            
            # Build filter conditions
            conditions = []
            
            if filters.get('genre'):
                conditions.append(f"LOWER(genre) = LOWER('{filters['genre']}')")
            
            if filters.get('artist'):
                conditions.append(f"LOWER(artist) = LOWER('{filters['artist']}')")
            
            if filters.get('year_min'):
                conditions.append(f"year >= {filters['year_min']}")
            
            if filters.get('year_max'):
                conditions.append(f"year <= {filters['year_max']}")
            
            if filters.get('tags'):
                tag_conditions = []
                for tag in filters['tags']:
                    tag_conditions.append(f"LOWER(tags) LIKE '%{tag.lower()}%'")
                if tag_conditions:
                    conditions.append(f"({' OR '.join(tag_conditions)})")
            
            # Apply filters
            if conditions:
                where_clause = " AND ".join(conditions)
                result = table.search().where(where_clause).limit(limit).to_df()
            else:
                result = table.to_pandas().head(limit)
            
            # Convert to Track objects
            tracks = []
            for _, row in result.iterrows():
                track_data = row.to_dict()
                track = dict_to_track(track_data)
                tracks.append(track)
            
            return tracks
            
        except Exception as e:
            logger.error(f"Failed to get tracks by filters: {str(e)}")
            raise
    
    async def get_stats(self) -> DatabaseStats:
        """Get database statistics."""
        try:
            stats = await get_database_stats(self.db)
            return DatabaseStats(**stats)
            
        except Exception as e:
            logger.error(f"Failed to get database stats: {str(e)}")
            raise
    
    async def clear_database(self) -> None:
        """Clear all tracks from the database."""
        try:
            table = get_tracks_table(self.db)
            
            # Get all track IDs to delete
            df = table.to_pandas()
            if df.empty:
                logger.info("Database is already empty")
                return
            
            # Delete all tracks using a more specific condition
            # First get the track IDs to ensure we have something to delete
            track_ids = df['track_id'].tolist()
            if not track_ids:
                logger.info("No tracks found to delete")
                return
            
            # Delete tracks by ID (more reliable than "1=1")
            for track_id in track_ids:
                try:
                    table.delete(f"track_id = '{track_id}'")
                except Exception as e:
                    logger.warning(f"Failed to delete track {track_id}: {str(e)}")
                    continue
            
            logger.info(f"Cleared database: removed {len(track_ids)} tracks")
            
        except Exception as e:
            logger.error(f"Failed to clear database: {str(e)}")
            raise
    
    async def update_track_embeddings(self, track_id: str, text_embedding: Optional[List[float]] = None, 
                                    image_embedding: Optional[List[float]] = None, 
                                    audio_embedding: Optional[List[float]] = None,
                                    semantic_embedding: Optional[List[float]] = None,
                                    lyrics_embedding: Optional[List[float]] = None) -> bool:
        """Update embeddings for an existing track."""
        try:
            # Get existing track
            existing_track = await self.get_track(track_id)
            if not existing_track:
                return False
            
            # Update embeddings
            updated_track = Track(
                track_id=track_id,
                title=existing_track.title,
                artist=existing_track.artist,
                album=existing_track.album,
                year=existing_track.year,
                genre=existing_track.genre,
                tags=existing_track.tags,
                youtube_url=existing_track.youtube_url,
                album_art_url=existing_track.album_art_url,
                lyrics=existing_track.lyrics,
                semantic_description=existing_track.semantic_description,
                mood=existing_track.mood,
                tempo=existing_track.tempo,
                instruments=existing_track.instruments,
                text_embedding=text_embedding if text_embedding is not None else existing_track.text_embedding,
                image_embedding=image_embedding if image_embedding is not None else existing_track.image_embedding,
                audio_embedding=audio_embedding if audio_embedding is not None else existing_track.audio_embedding,
                semantic_embedding=semantic_embedding if semantic_embedding is not None else existing_track.semantic_embedding,
                lyrics_embedding=lyrics_embedding if lyrics_embedding is not None else existing_track.lyrics_embedding,
                created_at=existing_track.created_at,
                updated_at=datetime.utcnow()
            )
            
            # Convert to dictionary for database storage
            track_dict = track_to_dict(updated_track)
            
            # Update in database
            table = get_tracks_table(self.db)
            table.update(where=f"track_id = '{track_id}'", values=track_dict)
            
            logger.info(f"Updated embeddings for track: {track_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to update track embeddings: {str(e)}")
            raise
